.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Format 3"
.TH Text::Format 3 "2019-03-14" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Format \- Various subroutines to format text.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Text::Format;
\&
\&    my $text = Text::Format\->new (
\&        {
\&            text           =>  [], # all
\&            columns        =>  72, # format, paragraphs, center
\&            leftMargin     =>   0, # format, paragraphs, center
\&            rightMargin    =>   0, # format, paragraphs, center
\&            firstIndent    =>   4, # format, paragraphs
\&            bodyIndent     =>   0, # format, paragraphs
\&            rightFill      =>   0, # format, paragraphs
\&            rightAlign     =>   0, # format, paragraphs
\&            justify        =>   0, # format, paragraphs
\&            extraSpace     =>   0, # format, paragraphs
\&            abbrevs        =>  {}, # format, paragraphs
\&            hangingIndent  =>   0, # format, paragraphs
\&            hangingText    =>  [], # format, paragraphs
\&            noBreak        =>   0, # format, paragraphs
\&            noBreakRegex   =>  {}, # format, paragraphs
\&            tabstop        =>   8, # expand, unexpand,  center
\&        }
\&    ); # these are the default values
\&
\&    my %abbr = (foo => 1, bar => 1);
\&    $text\->abbrevs(\e%abbr);
\&    $text\->abbrevs();
\&    $text\->abbrevs({foo => 1,bar => 1});
\&    $text\->abbrevs(qw/foo bar/);
\&    $text\->text(\e@text);
\&
\&    $text\->columns(132);
\&    $text\->tabstop(4);
\&    $text\->extraSpace(1);
\&    $text\->firstIndent(8);
\&    $text\->bodyIndent(4);
\&    $text\->config({tabstop => 4,firstIndent => 0});
\&    $text\->rightFill(0);
\&    $text\->rightAlign(0);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBformat\fR routine will format under all circumstances even if the
width isn't enough to contain the longest words.  \fIText::Wrap\fR will die
under these circumstances, although I am told this is fixed.  If columns
is set to a small number and words are longer than that and the leading
\&'whitespace' than there will be a single word on each line.  This will
let you make a simple word list which could be indented or right
aligned.  There is a chance for croaking if you try to subvert the
module.  If you don't pass in text then the internal text is worked on,
though not modfied.
.PP
\&\fIText::Format\fR is meant for more powerful text formatting than what
\&\fIText::Wrap\fR allows.  I also have a module called \fIText::NWrap\fR that
is meant as a direct replacement for \fIText::Wrap\fR.  \fIText::NWrap\fR
requires \fIText::Format\fR since it uses \fIText::Format\->format\fR to do the
actual wrapping but gives you the interface of \fIText::Wrap\fR.
.PP
General setup should be explained with the below graph.
.PP
.Vb 4
\&                           columns
\&<\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&<\-\-\-\-\-\-\-\-\-\-><\-\-\-\-\-\-><\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-><\-\-\-\-\-\-\-\-\-\-\->
\& leftMargin  indent  text is formatted into here  rightMargin
.Ve
.PP
indent is firstIndent or bodyIndent depending on where we are in the
paragraph.
.ie n .IP "\fBformat\fR @ARRAY || \e@ARRAY || [<\s-1FILEHANDLE\s0>] || \s-1NOTHING\s0" 4
.el .IP "\fBformat\fR \f(CW@ARRAY\fR || \e@ARRAY || [<\s-1FILEHANDLE\s0>] || \s-1NOTHING\s0" 4
.IX Item "format @ARRAY || @ARRAY || [<FILEHANDLE>] || NOTHING"
Allows one to do some advanced formatting of text into a paragraph, with
indent for first line and body set separately.  Can specify total width
of text, right fill with spaces or right align or justify (align to both
margins), right margin and left margin, non-breaking space, two spaces
at end of sentence, hanging indents (tagged paragraphs).  Strips all
leading and trailing whitespace before proceeding.  Text is first split
into words and then reassembled.  If no text is passed in then the
internal text in the object is formatted.
.ie n .IP "\fBparagraphs\fR @ARRAY || \e@ARRAY || [<\s-1FILEHANDLE\s0>] || \s-1NOTHING\s0" 4
.el .IP "\fBparagraphs\fR \f(CW@ARRAY\fR || \e@ARRAY || [<\s-1FILEHANDLE\s0>] || \s-1NOTHING\s0" 4
.IX Item "paragraphs @ARRAY || @ARRAY || [<FILEHANDLE>] || NOTHING"
Considers each element of text as a paragraph and if the indents are the
same for first line and the body then the paragraphs are separated by a
single empty line otherwise they follow one under the other.  If hanging
indent is set then a single empty line will separate each paragraph as
well.  Calls \fIformat\fR to do the actual formatting.  If no text is
passed in then the internal text in the object is formatted, though not
changed.
.ie n .IP "\fBcenter\fR @ARRAY || \s-1NOTHING\s0" 4
.el .IP "\fBcenter\fR \f(CW@ARRAY\fR || \s-1NOTHING\s0" 4
.IX Item "center @ARRAY || NOTHING"
Centers a list of strings in \f(CW@ARRAY\fR or internal text.  Empty lines
appear as, you guessed it, empty lines.  Center strips all leading and
trailing whitespace before proceeding.  Left margin and right margin can
be set.  If no text is passed in then the internal text in the object is
formatted.
.ie n .IP "\fBexpand\fR @ARRAY || \s-1NOTHING\s0" 4
.el .IP "\fBexpand\fR \f(CW@ARRAY\fR || \s-1NOTHING\s0" 4
.IX Item "expand @ARRAY || NOTHING"
Expand tabs in the list of text to tabstop number of spaces in \f(CW@ARRAY\fR or
internal text.  Doesn't modify the internal text just passes back the
modified text.  If no text is passed in then the internal text in the
object is formatted.
.ie n .IP "\fBunexpand\fR @ARRAY || \s-1NOTHING\s0" 4
.el .IP "\fBunexpand\fR \f(CW@ARRAY\fR || \s-1NOTHING\s0" 4
.IX Item "unexpand @ARRAY || NOTHING"
Tabstop number of spaces are turned into tabs in \f(CW@ARRAY\fR or internal
text.  Doesn't modify the internal text just passes back the modified
text.  If no text is passed in then the internal text in the object is
formatted.
.IP "\fBnew\fR \e%HASH || \s-1NOTHING\s0" 4
.IX Item "new %HASH || NOTHING"
Instantiates the object.  If you pass a reference to a hash, or an
anonymous hash then it is used in setting attributes.
.IP "\fBconfig\fR \e%HASH" 4
.IX Item "config %HASH"
Allows the configuration of all object attributes at once.  Returns the
object prior to configuration.  You can use it to make a clone of your
object before you change attributes.
.IP "\fBcolumns\fR \s-1NUMBER\s0 || \s-1NOTHING\s0" 4
.IX Item "columns NUMBER || NOTHING"
Set width of text or retrieve width.  This is total width and includes
indentation and the right and left margins.
.IP "\fBtabstop\fR \s-1NUMBER\s0 || \s-1NOTHING\s0" 4
.IX Item "tabstop NUMBER || NOTHING"
Set tabstop size or retrieve tabstop size, only used by expand, unexpand
and center.
.IP "\fBfirstIndent\fR \s-1NUMBER\s0 || \s-1NOTHING\s0" 4
.IX Item "firstIndent NUMBER || NOTHING"
Set or get indent for the first line of paragraph.  This is the number
of spaces to indent.
.IP "\fBbodyIndent\fR \s-1NUMBER\s0 || \s-1NOTHING\s0" 4
.IX Item "bodyIndent NUMBER || NOTHING"
Set or get indent for the body of paragraph.  This is the number of
spaces to indent.
.IP "\fBleftMargin\fR \s-1NUMBER\s0 || \s-1NOTHING\s0" 4
.IX Item "leftMargin NUMBER || NOTHING"
Set or get width of left margin.  This is the number of spaces used for
the margin.
.IP "\fBrightMargin\fR \s-1NUMBER\s0 || \s-1NOTHING\s0" 4
.IX Item "rightMargin NUMBER || NOTHING"
Set or get width of right margin.  This is the number of spaces used for
the margin.
.IP "\fBrightFill\fR 0 || 1 || \s-1NOTHING\s0" 4
.IX Item "rightFill 0 || 1 || NOTHING"
Set right fill or retrieve its value.  The filling is done with spaces.
Keep in mind that if \fIrightAlign\fR is also set then both \fIrightFill\fR
and \fIrightAlign\fR are ignored.
.IP "\fBrightAlign\fR 0 || 1 || \s-1NOTHING\s0" 4
.IX Item "rightAlign 0 || 1 || NOTHING"
Set right align or retrieve its value.  Text is aligned with the right
side of the margin.  Keep in mind that if \fIrightFill\fR is also set then
both \fIrightFill\fR and \fIrightAlign\fR are ignored.
.IP "\fBjustify\fR 0 || 1 || \s-1NOTHING\s0" 4
.IX Item "justify 0 || 1 || NOTHING"
Set justify or retrieve its value.  Text is aligned with both margins,
adding extra spaces as necessary to align text with left and right
margins.  Keep in mind that if either of \fIrightAlign\fR or \fIrightFill\fR
are set then \fIjustify\fR is ignored, even if both are set in which case
they are all ignored.
.IP "\fBtext\fR \e@ARRAY || \s-1NOTHING\s0" 4
.IX Item "text @ARRAY || NOTHING"
Pass in a reference to your text, or an anonymous array of text that you
want the routines to manipulate.  Returns the text held in the object.
.IP "\fBhangingIndent\fR 0 || 1 || \s-1NOTHING\s0" 4
.IX Item "hangingIndent 0 || 1 || NOTHING"
Use hanging indents in front of a paragraph, returns current value of
attribute.  This is also called a tagged paragraph.
.IP "\fBhangingText\fR \e@ARRAY || \s-1NOTHING\s0" 4
.IX Item "hangingText @ARRAY || NOTHING"
The text that will be displayed in front of each paragraph, if you call
\&\fIformat\fR then only the first element is used, if you call \fIparagraphs\fR
then \fIparagraphs\fR cycles through all of them.  If you have more
paragraphs than elements in your array than the remainder of the
paragraphs will not have a hanging indented text.  Pass a reference to
your array.  This is also called a tagged paragraph.
.IP "\fBnoBreak\fR 0 || 1 || \s-1NOTHING\s0" 4
.IX Item "noBreak 0 || 1 || NOTHING"
Set whether you want to use the non-breaking space feature (see
\&\fBnoBreakRegex\fR below).
.IP "\fBnoBreakRegex\fR \e%HASH || \s-1NOTHING\s0" 4
.IX Item "noBreakRegex %HASH || NOTHING"
Pass in a reference to a hash that would hold the regexes on which not
to break. In order for this to happen, it requires \fBnoBreak\fR to be set
to \fBtrue\fR \- see above.  Without any arguments, it
returns the hash. E.g:
.Sp
.Vb 1
\&    {\*(Aq^Mrs?\e.$\*(Aq => \*(Aq^\eS+$\*(Aq,\*(Aq^\eS+$\*(Aq => \*(Aq^(?:S|J)r\e.$\*(Aq}
.Ve
.Sp
don't break names such as
Mr. Jones, Mrs. Jones, Jones Jr.
.Sp
The breaking algorithm is simple.  If there should not be a break at the
current end of sentence, then a backtrack is done till there are two
words on which breaking is allowed.  If no two such words are found then
the end of sentence is broken anyhow.  If there is a single word on
current line then no backtrack is done and the word is stuck on the end.
This is so you can make a list of names for example.
.Sp
\&\fBNote\fR: this feature requires \fBnoBreak\fR to be set to true.
.IP "\fBextraSpace\fR 0 || 1 || \s-1NOTHING\s0" 4
.IX Item "extraSpace 0 || 1 || NOTHING"
Add extra space after end of sentence, normally \fIformat\fR would add 1
space after end of sentence, if this is set to 1 then 2 spaces are used.
Abbreviations are not followed by two spaces.  There are a few internal
abbreviations and you can add your own to the object with \fIabbrevs\fR
.ie n .IP "\fBabbrevs\fR \e%HASH || @ARRAY || \s-1NOTHING\s0" 4
.el .IP "\fBabbrevs\fR \e%HASH || \f(CW@ARRAY\fR || \s-1NOTHING\s0" 4
.IX Item "abbrevs %HASH || @ARRAY || NOTHING"
Add to the current abbreviations, takes a reference to your hash or an
array of abbreviations, if called a second time the original reference
is removed and replaced by the new one.  Returns the current \s-1INTERNAL\s0
abbreviations.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 1
\&    use Text::Format;
\&
\&    my $text = Text::Format\->new;
\&
\&    $text\->rightFill(1);
\&    $text\->columns(65);
\&    $text\->tabstop(4);
\&
\&    print $text\->format("a line to format to an indented regular
\&            paragraph using 65 character wide display");
\&    print $text\->paragraphs("paragraph one","paragraph two");
\&    print $text\->center("hello world","nifty line 2");
\&    print $text\->expand("\et\ethello world\en","hmm,\etwell\en");
\&    print $text\->unexpand("    hello world\en","    hmm");
\&
\&    $text\->config({columns => 132, tabstop => 4});
\&
\&    $text = Text::Format\->new();
\&
\&    print $text\->format(@text);
\&    print $text\->paragraphs(@text);
\&    print $text\->center(@text);
\&    print $text\->format([<FILEHANDLE>]);
\&    print $text\->format([$fh\->getlines()]);
\&    print $text\->paragraphs([<FILEHANDLE>]);
\&    print $text\->expand(@text);
\&    print $text\->unexpand(@text);
\&
\&    $text = Text::Format\->new
\&        ({tabstop => 4,bodyIndent => 4,text => \e@text});
\&
\&    print $text\->format();
\&    print $text\->paragraphs();
\&    print $text\->center();
\&    print $text\->expand();
\&    print $text\->unexpand();
\&
\&    print Text::Format\->new({columns => 95})\->format(@text);
.Ve
.SH "BUGS"
.IX Header "BUGS"
Line length can exceed the number of specified columns
if columns is set to a small number and long words plus leading whitespace
exceed the specified column length.  Actually I see this as a feature since it
can be used to make up a nice word list.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1998 Gabor Egressy.  All rights reserved.
.PP
This program is free software; you can redistribute and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gabor Egressy \fBgabor@vmunix.com\fR
.PP
Copyright (c) 1998 Gabor Egressy.  All rights reserved.  All wrongs
reversed.  This program is free software; you can redistribute and/or
modify it under the same terms as Perl itself.
.PP
Adopted and modified by Shlomi Fish, <http://www.shlomifish.org/> \- all
rights disclaimed.
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
\&\fBTom Phoenix\fR
.PP
Found a bug with code for two spaces at the end of the sentence and provided
a code fragment for a better solution. Also some preliminary suggestions on
the design.
.PP
\&\fBBrad Appleton\fR
.PP
Suggestion and explanation of hanging indents, suggestion for
non-breaking whitespace, general suggestions with regard to interface
design.
.PP
\&\fBByron Brummer\fR
.PP
Suggestion for better interface design and object design, code for
better implementation of getting abbreviations.
.PP
\&\fBH. Merijn Brand\fR
.PP
Suggestion for a justify feature and original code for doing the
justification.  I changed the code to take into account the extra space
at end of sentence feature.
.PP
\&\fBAnne Wainwright\fR
.PP
Inspired a documentation clarification about \fBnoBreak\fR required by
\&\fBnoBreakRegex\fR , thanks to a report with a problem.
.SH "TODO"
.IX Header "TODO"
